category <- gsub("[\\W]", "", dirs[f], perl=TRUE)
category <- gsub("[[:blank:]]", "_", category)
listname <- category
###END create wordlistnames on basis of names of the directory--------------------
#add a number to the wordlist in case any names are duplicates
listname <- paste("c",f,"__",listname,sep="")
names(wordlists)[f] <- listname
}
##END read word list names---------------------------------------
#can also be done right before ploting with the result.matrix -> maybe easier....
#generate textlist selection for plotting
#i.e. combine the hannover matrices to one
# names(textlist)
# hannover <- "x_GER_Hannover_2008_KSAP_Materialband_CPC1_main_appendix"
# for (i in 1:8) {
#  }
delete.word.rows <- c("Energieverbrauch", "Energieprodukt")
#from script to check which have the highest occurrence, the following table shows up,
#   #for a threshold of 80%
#   word             category
# 18044   Energieeinspar      c35__EN__saving
# 17268 Energieverbrauch c26__EN__consumption
# 17855           Energi     c33__EN__general
# 18031   Energieprodukt       c34__EN__sales
occurrence.filename.tag <- c("__w_occ_mat__MR")
#START evaluation energy chain----------------------------------
##START select the categories which shall be checked on occurrence from the available wordlistnames------------------
categories <- names(wordlists)
categories.num <-length(categories)
##END select the categories which shall be checked on occurrence from the available wordlistnames------------------
##START count (percentaged) occurrence of categories within each text: (occurrence of category within X measures of a text)/(number of all measures in a text)-------------------------
###START - do counting and create results matrix-------------------------
setwd(wd.interim)
files <- list.files(pattern = paste("^.*", occurrence.filename.tag, "[[:digit:]]+.csv$", sep=""))
exclude.cases <- c("Hannover96",
"Wilhelmshaven__CPC1_main_short"
)
exclude.cases <- grep(paste(exclude.cases, collapse="|"), files)
if (length(exclude.cases) > 0) {
files <- files[-exclude.cases]
}
#initial
result.energychain <- matrix(rep(0, categories.num*length(files)), nrow = categories.num)
row.names(result.energychain) <- categories
colnames(result.energychain) <- rep("dummy", ncol(result.energychain))
for (t in seq(length(files))) {
#print(files[t])
evaluationmatrix <- read.csv(files[t], header = TRUE)
#if reading in of the csv generates a column with numbers (old rownubers) this column is deleted
if(colnames(evaluationmatrix)[1] == "X") {
evaluationmatrix <- evaluationmatrix[,-c(1)]
}
meas.totalnum <- ncol(evaluationmatrix)-2
#delete rows with words that occur in almost all measures (not representative)
evaluationmatrix <- evaluationmatrix[-which(as.character(evaluationmatrix[,"word"]) %in% delete.word.rows),]
#delete the words column
evaluationmatrix <-   evaluationmatrix[,-c(1)]
#aggregate the category lines
evaluationmatrix <- aggregate(evaluationmatrix[2:ncol(evaluationmatrix)], by=list(category=evaluationmatrix$category), FUN=sum)
#make matrix boolean
evaluationmatrix[,c(2:ncol(evaluationmatrix))] <- ifelse(evaluationmatrix[,c(2:ncol(evaluationmatrix))]>0,1,0)
#in future steps maybe also the year, etc. is extracted and used as name
colnames(result.energychain)[t] <- gsub(paste("(^.*GER__)([A-Za-z]+)(__.*$)"), "\\2",files[t])
for(i in seq(length(categories))) {
#print(categories[i])
#i=1
category <- categories[i]
#select only the lines which are connected to (contain) a word which refers to the respective category of the energy chain
#if the category is a combined category it has to be split to be suitable for the which==XX inquiry (if this operation is done outside below line, an additional variable like category.unl has to be introduced, othwerwise the category name is wrong for finding it again in the resultmatrix)
category.subset <- evaluationmatrix[which(evaluationmatrix[,"category"] %in% unlist(strsplit(category, "~~"))),]
category.subset.counts <- category.subset[,c(2:ncol(category.subset))]
count <- colSums(category.subset.counts)
#only "boolean-counting"/"occurrence at all" applied, word frequency within a measure is not used for evaluation
#therefore all numbers larger than 0 are converted to a 1
count <- ifelse(count>0,1,0)
result <- round(sum(count)/meas.totalnum, digits=4)
result.energychain[category,t] <- result
}
}
#add MEAN over all columns as last column
result.energychain  <- cbind(result.energychain, round((rowSums(result.energychain)/ncol(result.energychain)), digits=4))
colnames(result.energychain)[ncol(result.energychain)] <- "mean"
###END - do counting and create results matrix-------------------------
#dimnames(result.energychain)
###START ORDER the rows according to the energy chain order--------------------------
#result.energychain <- result.energychain[rows.ordered ,]
###END ORDER the rows according to the energy chain order--------------------------
##START count (percentaged) occurrence of categories within each text: (occurrence of category within X measures of a text)/(number of all measures in a text)-------------------------
#END evaluation energy chain----------------------------------
#START Plot energychain - boxplot-------------------------------------
#rownames(result.energychain) <- as.character(result.energychain[,1])
#result.energychain <- result.energychain[,-1]
rownames(result.energychain) <- gsub("c[[:digit:]]+__", "",rownames(result.energychain) )
rownames(result.energychain) <- gsub("LEV__fed_state_NIS_state", "LEV__state_LSaxony",rownames(result.energychain))
result.energychain <- t(result.energychain)
exclude.cols <- c("LEV__fed")
exclude.cols <- as.numeric(sapply(exclude.cols, function(item) grep(item, colnames(result.energychain))))
if (length(exclude.cols) > 0) {
result.energychain <- result.energychain[,-exclude.cols]
}
result.energychain <- as.data.frame(result.energychain)
result.energychain <- cbind(rownames(result.energychain), result.energychain)
colnames(result.energychain)[1] <- "case"
rownames(result.energychain) <- NULL
results.melt <- melt(result.energychain, id.vars= c("case"))
plot.results <- results.melt
#plot.results[,2] <- gsub("^.*__", "", plot.results[,2])
#exclude mean value and energy general
plot.results <- subset(plot.results, plot.results$case == "mean")
#plot.results <- subset(plot.results, plot.results$case != "mean")
#store information which bars refer to "TOTAL" categories in order to colour them differently
#Reassign the levels in order to preserve the order as displayed in the data
row.names(plot.results) <- 1:nrow(plot.results)
plot.results$variable <- factor(plot.results$variable, levels = unique(plot.results$variable))
x.axis.label.size <- c(6)
y.axis.label.size <- c(6)
y.axis.title.size <- c(6)
annotate.label.size <-c(5)
min25 <- plot.results[which(plot.results$value >= 0.25),]
min25 <- min25[order(min25["value"], decreasing = TRUE),]
wd <- getwd()
setwd(wd.final)
write.csv(min25, "categories_with_minimum_normalized_occurrence_of_25.csv")
setwd(wd)
#----------------------plot-----------------------
c <- ggplot(plot.results, aes(factor(variable), value), stat = "identity")
#c + geom_boxplot(outlier.colour = "black") + #width: distance between bars
c + geom_bar(stat="identity", width=.8) + #width: distance between bars
ylab("relative occurrence of category in set of measures [%]") +
xlab("") +
#theme black and white
theme_bw() +
#colour set for columns
scale_fill_grey(start = 1, end = 0.4, na.value = "red") +
#eliminates background, gridlines, and chart border
theme(plot.background = element_blank()
,panel.grid.major = element_blank()
,panel.grid.minor = element_blank()
,panel.border = element_rect(colour = "black")
,axis.line = element_line(colour = "black")
,legend.position = "bottom"
# ,legend.key.size = unit(2.5, "cm")
) +
# Rotate x-axis labels
theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.25, size=x.axis.label.size )) +
#set y-axis tick sizes
theme(axis.text.y = element_text(size=y.axis.label.size[1])) +
#set the limits of the y axis
scale_y_continuous(expand = c(0,0), limits = c(0,1)) +
coord_fixed(ratio = 20) +
#set distance of y axis label to the axis
theme(axis.title.y = element_text(vjust=1.1, size=y.axis.title.size)) +
geom_hline(yintercept = 0.25, colour = "black", linetype= "dashed", size=.01) +
#force start of the bars directly at the axis (without the distance) - NOT WORKING WITH YLIM
#scale_y_continuous(expand = c(0,0)) +
#scale_x_discrete(expand = c(0,0)) +
#use a legend theme which includes a black rectangle around the legend
theme(legend.background = element_rect(colour = "black")) +
#remove crossing lines through the colouer fields in the legend
guides(fill = guide_legend(override.aes = list(colour = NULL))) +
#don´t show legend
theme(legend.position = "none")
#----------------------plot-----------------------
##<<<<<<<<---Export - Save as Metafile
wd <- getwd()
setwd(wd.final)
#ggsave(file="energy_chain_occurrence_plot.pdf")
ggsave(file="all_systems_occurrence_boxplot.emf")
setwd(wd)
#START Plot energychain - boxplot-------------------------------------
#START plot energy chain - only mean----------------------------
plot.results.mean <- results.melt
plot.results.mean[,2] <- gsub("^.*__", "", plot.results.mean[,2])
#select mean value and exclude energy_general category
plot.results.mean <- subset(plot.results.mean, plot.results.mean$variable == "mean")
plot.results.mean <- subset(plot.results.mean, plot.results.mean$maincategory != "energy_general")
#tail(plot.results.mean, 20)
#head(plot.results.mean,50)
#names(plot.results.mean)
#Reassign the levels in order to preserve the order as displayed in the data
plot.results.mean$category <- factor(plot.results.mean$category, levels = unique(plot.results.mean$category))
row.names(plot.results.mean) <- 1:nrow(plot.results.mean)
for (i in seq(length(ncol(plot.results.mean))))    {
plot.results.mean[,i] <- factor(plot.results.mean[,i], levels = unique(plot.results.mean[,i]))
}
#for cecking the data in wide format
#casttest <- dcast(plot.results.mean, maincategory + category ~ variable, value.var = "value")
#plot.results.mean <- plot.results.mean[-which(plot.results.mean[,"variable"] == c("Hannover")),]
vertical.line <- grep("^TOTAL_", unique(plot.results.mean$category))
vertical.line <- vertical.line[-c(1)]
vertical.line  <- vertical.line-.5
vertical.line
#
#
# annotate.text <- grep("^TOTAL_", unique(plot.results.mean$category))
# annotate.text <- annotate.text[-c(1)]
# annotate.text  <- c(0, annotate.text, length(unique(plot.results.mean$category)))
#
# annotate.position <- vector(mode="numeric", length= length(annotate.text)-1 )
# for (i in 1:(length(annotate.text)-1)) {
#
#   annotate.position[i] <- annotate.text[i]+(annotate.text[i+1]-annotate.text[i])/2
#
# }
c <- ggplot(plot.results.mean, aes(category,value, fill=maincategory)) # fill = category?
c + geom_bar(stat = "identity", position = "dodge", colour = "black", width = 0.5, show_guide=TRUE) + #width: distance between bars
ylab("") +
xlab("") +
#theme black and white
theme_bw() +
#colour set for columns
scale_fill_grey(start = 1, end = 0.2, na.value = "red") +
#eliminates background, gridlines, and chart border
theme(plot.background = element_blank()
,panel.grid.major = element_blank()
,panel.grid.minor = element_blank()
,panel.border = element_rect(colour = "black")
,axis.line = element_line(colour = "black")
,legend.position = "bottom"
# ,legend.key.size = unit(2.5, "cm")
) +
# Rotate x-axis labels
theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.25, size=14)) +
#set the limits of the y axis
scale_y_continuous(expand = c(0,0), limits = c(0,.5)) +
#force start of the bars directly at the axis (without the distance) - NOT WORKING WITH YLIM
#scale_y_continuous(expand = c(0,0)) +
#scale_x_discrete(expand = c(0,0)) +
#use a legend theme which includes a black rectangle around the legend
theme(legend.background = element_rect(colour = "black")) +
geom_vline(aes(xintercept = c(rep(4.5,  nrow(plot.results.mean)))), linetype= "dashed") +
geom_vline(aes(xintercept = c(rep(10.5, nrow(plot.results.mean)))), linetype= "dashed") +
geom_vline(aes(xintercept = c(rep(14.5, nrow(plot.results.mean)))), linetype= "dashed") +
geom_vline(aes(xintercept = c(rep(19.5, nrow(plot.results.mean)))), linetype= "dashed") +
geom_vline(aes(xintercept = c(rep(29.5, nrow(plot.results.mean)))), linetype= "dashed") +
geom_vline(aes(xintercept = c(rep(32.5, nrow(plot.results.mean)))), linetype= "dashed") +
#  geom_vline(aes(xintercept = c(rep(39.5, nrow(plot.results.mean)))), linetype= "dashed") +
#   annotate("text", x = annotate.position[1], y = .48, label = "resources") +
#   annotate("text", x = annotate.position[2], y = .48, label = "conversion") +
#   annotate("text", x = annotate.position[3], y = .48, label = "distribution") +
#   annotate("text", x = annotate.position[4], y = .48, label = "sales") +
#   annotate("text", x = annotate.position[5], y = .48, label = "mobility") +
#   annotate("text", x = annotate.position[6], y = .48, label = "technology") +
#   annotate("text", x = annotate.position[7], y = .48, label = "end use") +
#remove crossing lines through the colouer fields in the legend
guides(fill = guide_legend(override.aes = list(colour = NULL)))
library("ggplot2")
library("reshape2")
warning("Please make sure that categories have been named and combined by hand within the script.")
library("plyr")
#START - directories
wd.main <- c("M:/Science/Promotion/R_CPC_evaluation_of_measures/")
wd.source <- paste(wd.main, "text_files/", sep="")
wd.interim <- paste(wd.main, "results_interim/", sep="")
wd.final <- paste(wd.main, "results_final/", sep="")
wd.wordlists <- paste(wd.main, "wordlists/", sep="")
wd.stopwords <- paste(wd.main, "wordlists_stopwords/", sep="")
wd.encoding <- paste(wd.main, "encoding/", sep="")
wd.notmatched <- paste(wd.main, "wordlist_notmatched_words/", sep="")
#initialize an empty txt.file if there is no file, yet
if (c("wordlist_notmatched_words.txt") %in% list.files(path = wd.notmatched) == FALSE) {
writeLines(c(""), paste(wd.notmatched, "wordlist_notmatched_words.txt", sep="") )
}
##START read word list names---------------------------------------
setwd(paste(wd.wordlists, "wordlists_for_analysis/", sep=""))
dir_current_root <- paste(getwd(), "/", sep="")
dirs <- list.dirs()
#the root dir is included as a single dot and is excluded, also leading dots are deleted and a final slash is added
dirs <- dirs[grep("[[:alpha:]]", dirs)]
dirs <- paste(gsub("./", "", dirs, fixed=TRUE),"/" , sep="")
#initialize list
wordlists <- vector(mode = "list", length = length(dirs))
for (f in 1:length(dirs)) {
setwd(paste(dir_current_root, dirs[f], sep=""))
category <- gsub("[\\W]", "", dirs[f], perl=TRUE)
category <- gsub("[[:blank:]]", "_", category)
listname <- category
###END create wordlistnames on basis of names of the directory--------------------
#add a number to the wordlist in case any names are duplicates
listname <- paste("c",f,"__",listname,sep="")
names(wordlists)[f] <- listname
}
##END read word list names---------------------------------------
#can also be done right before ploting with the result.matrix -> maybe easier....
#generate textlist selection for plotting
#i.e. combine the hannover matrices to one
# names(textlist)
# hannover <- "x_GER_Hannover_2008_KSAP_Materialband_CPC1_main_appendix"
# for (i in 1:8) {
#  }
delete.word.rows <- c("Energieverbrauch", "Energieprodukt")
#from script to check which have the highest occurrence, the following table shows up,
#   #for a threshold of 80%
#   word             category
# 18044   Energieeinspar      c35__EN__saving
# 17268 Energieverbrauch c26__EN__consumption
# 17855           Energi     c33__EN__general
# 18031   Energieprodukt       c34__EN__sales
occurrence.filename.tag <- c("__w_occ_mat__MR")
#START evaluation energy chain----------------------------------
##START select the categories which shall be checked on occurrence from the available wordlistnames------------------
categories <- names(wordlists)
categories.num <-length(categories)
##END select the categories which shall be checked on occurrence from the available wordlistnames------------------
##START count (percentaged) occurrence of categories within each text: (occurrence of category within X measures of a text)/(number of all measures in a text)-------------------------
###START - do counting and create results matrix-------------------------
setwd(wd.interim)
files <- list.files(pattern = paste("^.*", occurrence.filename.tag, "[[:digit:]]+.csv$", sep=""))
exclude.cases <- c("Hannover96",
"Wilhelmshaven__CPC1_main_short"
)
exclude.cases <- grep(paste(exclude.cases, collapse="|"), files)
if (length(exclude.cases) > 0) {
files <- files[-exclude.cases]
}
#initial
result.energychain <- matrix(rep(0, categories.num*length(files)), nrow = categories.num)
row.names(result.energychain) <- categories
colnames(result.energychain) <- rep("dummy", ncol(result.energychain))
for (t in seq(length(files))) {
#print(files[t])
evaluationmatrix <- read.csv(files[t], header = TRUE)
#if reading in of the csv generates a column with numbers (old rownubers) this column is deleted
if(colnames(evaluationmatrix)[1] == "X") {
evaluationmatrix <- evaluationmatrix[,-c(1)]
}
meas.totalnum <- ncol(evaluationmatrix)-2
#delete rows with words that occur in almost all measures (not representative)
evaluationmatrix <- evaluationmatrix[-which(as.character(evaluationmatrix[,"word"]) %in% delete.word.rows),]
#delete the words column
evaluationmatrix <-   evaluationmatrix[,-c(1)]
#aggregate the category lines
evaluationmatrix <- aggregate(evaluationmatrix[2:ncol(evaluationmatrix)], by=list(category=evaluationmatrix$category), FUN=sum)
#make matrix boolean
evaluationmatrix[,c(2:ncol(evaluationmatrix))] <- ifelse(evaluationmatrix[,c(2:ncol(evaluationmatrix))]>0,1,0)
#in future steps maybe also the year, etc. is extracted and used as name
colnames(result.energychain)[t] <- gsub(paste("(^.*GER__)([A-Za-z]+)(__.*$)"), "\\2",files[t])
for(i in seq(length(categories))) {
#print(categories[i])
#i=1
category <- categories[i]
#select only the lines which are connected to (contain) a word which refers to the respective category of the energy chain
#if the category is a combined category it has to be split to be suitable for the which==XX inquiry (if this operation is done outside below line, an additional variable like category.unl has to be introduced, othwerwise the category name is wrong for finding it again in the resultmatrix)
category.subset <- evaluationmatrix[which(evaluationmatrix[,"category"] %in% unlist(strsplit(category, "~~"))),]
category.subset.counts <- category.subset[,c(2:ncol(category.subset))]
count <- colSums(category.subset.counts)
#only "boolean-counting"/"occurrence at all" applied, word frequency within a measure is not used for evaluation
#therefore all numbers larger than 0 are converted to a 1
count <- ifelse(count>0,1,0)
result <- round(sum(count)/meas.totalnum, digits=4)
result.energychain[category,t] <- result
}
}
#add MEAN over all columns as last column
result.energychain  <- cbind(result.energychain, round((rowSums(result.energychain)/ncol(result.energychain)), digits=4))
colnames(result.energychain)[ncol(result.energychain)] <- "mean"
###END - do counting and create results matrix-------------------------
#dimnames(result.energychain)
###START ORDER the rows according to the energy chain order--------------------------
#result.energychain <- result.energychain[rows.ordered ,]
###END ORDER the rows according to the energy chain order--------------------------
##START count (percentaged) occurrence of categories within each text: (occurrence of category within X measures of a text)/(number of all measures in a text)-------------------------
#END evaluation energy chain----------------------------------
#START Plot energychain - boxplot-------------------------------------
#rownames(result.energychain) <- as.character(result.energychain[,1])
#result.energychain <- result.energychain[,-1]
rownames(result.energychain) <- gsub("c[[:digit:]]+__", "",rownames(result.energychain) )
rownames(result.energychain) <- gsub("LEV__fed_state_NIS_state", "LEV__state_LSaxony",rownames(result.energychain))
result.energychain <- t(result.energychain)
exclude.cols <- c("LEV__fed")
exclude.cols <- as.numeric(sapply(exclude.cols, function(item) grep(item, colnames(result.energychain))))
if (length(exclude.cols) > 0) {
result.energychain <- result.energychain[,-exclude.cols]
}
result.energychain <- as.data.frame(result.energychain)
result.energychain <- cbind(rownames(result.energychain), result.energychain)
colnames(result.energychain)[1] <- "case"
rownames(result.energychain) <- NULL
results.melt <- melt(result.energychain, id.vars= c("case"))
plot.results <- results.melt
#plot.results[,2] <- gsub("^.*__", "", plot.results[,2])
#exclude mean value and energy general
plot.results <- subset(plot.results, plot.results$case == "mean")
#plot.results <- subset(plot.results, plot.results$case != "mean")
#store information which bars refer to "TOTAL" categories in order to colour them differently
#Reassign the levels in order to preserve the order as displayed in the data
row.names(plot.results) <- 1:nrow(plot.results)
plot.results$variable <- factor(plot.results$variable, levels = unique(plot.results$variable))
x.axis.label.size <- c(6)
y.axis.label.size <- c(6)
y.axis.title.size <- c(6)
annotate.label.size <-c(5)
min25 <- plot.results[which(plot.results$value >= 0.25),]
min25 <- min25[order(min25["value"], decreasing = TRUE),]
wd <- getwd()
setwd(wd.final)
write.csv(min25, "categories_with_minimum_normalized_occurrence_of_25.csv")
setwd(wd)
#----------------------plot-----------------------
c <- ggplot(plot.results, aes(factor(variable), value), stat = "identity")
#c + geom_boxplot(outlier.colour = "black") + #width: distance between bars
c + geom_bar(stat="identity", width=.8) + #width: distance between bars
ylab("relative occurrence of category in set of measures [%]") +
xlab("") +
#theme black and white
theme_bw() +
#colour set for columns
scale_fill_grey(start = 1, end = 0.4, na.value = "red") +
#eliminates background, gridlines, and chart border
theme(plot.background = element_blank()
,panel.grid.major = element_blank()
,panel.grid.minor = element_blank()
,panel.border = element_rect(colour = "black")
,axis.line = element_line(colour = "black")
,legend.position = "bottom"
# ,legend.key.size = unit(2.5, "cm")
) +
# Rotate x-axis labels
theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.25, size=x.axis.label.size )) +
#set y-axis tick sizes
theme(axis.text.y = element_text(size=y.axis.label.size[1])) +
#set the limits of the y axis
scale_y_continuous(expand = c(0,0), limits = c(0,1)) +
coord_fixed(ratio = 20) +
#set distance of y axis label to the axis
theme(axis.title.y = element_text(vjust=1.1, size=y.axis.title.size)) +
geom_hline(yintercept = 0.25, colour = "black", linetype= "dashed", size=.01) +
#force start of the bars directly at the axis (without the distance) - NOT WORKING WITH YLIM
#scale_y_continuous(expand = c(0,0)) +
#scale_x_discrete(expand = c(0,0)) +
#use a legend theme which includes a black rectangle around the legend
theme(legend.background = element_rect(colour = "black")) +
#remove crossing lines through the colouer fields in the legend
guides(fill = guide_legend(override.aes = list(colour = NULL))) +
#don´t show legend
theme(legend.position = "none")
#----------------------plot-----------------------
library("ggplot2")
library("reshape2")
warning("Please make sure that categories have been named and combined by hand within the script.")
library("plyr")
##START read word list names---------------------------------------
setwd(paste(wd.wordlists, "wordlists_for_analysis/", sep=""))
dir_current_root <- paste(getwd(), "/", sep="")
dirs <- list.dirs()
#the root dir is included as a single dot and is excluded, also leading dots are deleted and a final slash is added
dirs <- dirs[grep("[[:alpha:]]", dirs)]
dirs <- paste(gsub("./", "", dirs, fixed=TRUE),"/" , sep="")
#initialize list
wordlists <- vector(mode = "list", length = length(dirs))
for (f in 1:length(dirs)) {
setwd(paste(dir_current_root, dirs[f], sep=""))
category <- gsub("[\\W]", "", dirs[f], perl=TRUE)
category <- gsub("[[:blank:]]", "_", category)
listname <- category
###END create wordlistnames on basis of names of the directory--------------------
#add a number to the wordlist in case any names are duplicates
listname <- paste("c",f,"__",listname,sep="")
names(wordlists)[f] <- listname
}
##END read word list names---------------------------------------
library("ggplot2")
library("reshape2")
warning("Please make sure that categories have been named and combined by hand within the script.")
library("plyr")
#START - directories
wd.main <- c("M:/Science/Promotion/R_CPC_evaluation_of_measures/")
wd.source <- paste(wd.main, "text_files/", sep="")
wd.interim <- paste(wd.main, "results_interim/", sep="")
wd.final <- paste(wd.main, "results_final/", sep="")
wd.wordlists <- paste(wd.main, "wordlists/", sep="")
wd.stopwords <- paste(wd.main, "wordlists_stopwords/", sep="")
wd.encoding <- paste(wd.main, "encoding/", sep="")
wd.notmatched <- paste(wd.main, "wordlist_notmatched_words/", sep="")
#initialize an empty txt.file if there is no file, yet
if (c("wordlist_notmatched_words.txt") %in% list.files(path = wd.notmatched) == FALSE) {
writeLines(c(""), paste(wd.notmatched, "wordlist_notmatched_words.txt", sep="") )
}
##START read word list names---------------------------------------
setwd(paste(wd.wordlists, "wordlists_for_analysis/", sep=""))
dir_current_root <- paste(getwd(), "/", sep="")
dirs <- list.dirs()
#the root dir is included as a single dot and is excluded, also leading dots are deleted and a final slash is added
dirs <- dirs[grep("[[:alpha:]]", dirs)]
dirs <- paste(gsub("./", "", dirs, fixed=TRUE),"/" , sep="")
#initialize list
wordlists <- vector(mode = "list", length = length(dirs))
for (f in 1:length(dirs)) {
setwd(paste(dir_current_root, dirs[f], sep=""))
category <- gsub("[\\W]", "", dirs[f], perl=TRUE)
category <- gsub("[[:blank:]]", "_", category)
listname <- category
###END create wordlistnames on basis of names of the directory--------------------
#add a number to the wordlist in case any names are duplicates
listname <- paste("c",f,"__",listname,sep="")
names(wordlists)[f] <- listname
}
##END read word list names---------------------------------------
getwd()
names(wordlists)
wd <- getwd()
setwd(wd.final)
write.csv(noquote(names(wordlists)), quote=F, row.names=F, "names_wordlists.csv")
write.csv(noquote(names(wordlists)), quote=F, row.names=F, col.names=F "names_wordlists.csv")
write.csv(noquote(names(wordlists)), quote=F, row.names=F, col.names=F, "names_wordlists.csv")
setwd(wd)
head(plot.results)
gsub("c[[:digit:]]+__", "",names(wordlists) )
wd <- getwd()
setwd(wd.final)
write.csv(noquote(gsub("c[[:digit:]]+__", "",names(wordlists))), quote=F, row.names=F, col.names=F, "names_wordlists.csv")
setwd(wd)
